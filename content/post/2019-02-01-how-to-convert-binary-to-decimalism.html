---
title: 'How to convert  binary to decimalism '
author: Sheng Luan
date: '2019-02-01'
categories:
  - 编程
tags:
  - R
slug: how-to-convert-binary-to-decimalism
header:
  caption: ''
  image: ''
  preview: yes
---



<p>今天跟儿子讨论，如何把二进制转换为十进制。二进制的规则是逢二进一，借一当二。我们写了一下0到9的二进制表示方法，也找到了转换方法。</p>
<div class="figure">
<img src="/post/images/bintodec.png" alt="二进制到十进制" />
<p class="caption">二进制到十进制</p>
</div>
<p>封装了一个函数：</p>
<pre class="r"><code>bin2dec &lt;- function(x) {
  n &lt;- nchar(x)
  sum &lt;- 0
  x_split &lt;- rev(unlist(strsplit(x,split = &quot;&quot;)))
  for (i in 1:n) {
    if(x_split[i] == 1) {
      sum &lt;- sum + 2^(i-1)
    }
  }
  return(sum)
}</code></pre>
<p>测试一下: c++中的short int 即16个bit可以表示的最大十进制数为：</p>
<pre class="r"><code>bin_str &lt;- paste(rep(&quot;1&quot;,16),collapse = &quot;&quot;)
print(bin_str)</code></pre>
<pre><code>## [1] &quot;1111111111111111&quot;</code></pre>
<pre class="r"><code>print(bin2dec(bin_str))</code></pre>
<pre><code>## [1] 65535</code></pre>
<p>但是在教科书中，我们通常看到，short int的取值范围在-32768 ~ 32767。这是因为在进行二进制计算时，需拿出了最左边的一位用于表示正负符号，1表示负号。因此实际可用的位数就变为了15位。 计算机二进制的表示方法有三种：原码，反码和补码。</p>
<p>对于正数，反码和补码跟原码是一样的。</p>
<p>对于负数，反码是指原码除了符号位不变，其余各位1 -&gt; 0,0 -&gt; 1；补码，是在反码的基础上加1。如下图所示：</p>
<div class="figure">
<img src="/post/images/bincalc1.png" alt="原码、反码和补码示例1" />
<p class="caption">原码、反码和补码示例1</p>
</div>
<p>计算机在计算时，通常只会执行加法操作，减法通常也会转换为加法，而且为了加快计算速度，符号位也需要直接参与计算。从上图中可以看到，如果符号位直接参与计算，利用原码得到的计算结果是错误的。而利用反码，会得到-0，这意味着0有正负两种形式。而利用补码，可以得到正确的值。</p>
<p>继续看下边的例子，有一个更深刻的印象： <img src="/post/images/bincalc2.png" alt="原码、反码和补码示例2" /></p>
